

6/12/14:
	Worked on the Python and Java files. I've looked more into the documentation and I know the methods I need to call to the API
	for exactly what I want. Event list to get all games and then marketbook for an event list id that interests me. I'm starting
	to think about the UI so I know that there's some code thats' unnecessary right now but will be needed in the end for users to 
	pick events they want to monitor. I've found an error on the betfair api pages which caused my python code to get prices for bets
	to not work for almost a week now. It gave the wrong URL to post to which is incredibly annoying... I implemented some Java to get
	event information but it wasn't the correct method, it listed markets like Manchester to win but it wasn't for a particular game. It
	listed all markets like that for all games in my time period but didn't mention the actual game like Manchester Vs Liverpool. It would
	list manchester and liverpool markets and then other game markets without mentioning anything. Huge message today but I did spend quite
	some time today and I've forgotten about my log for a while now. Plan is to fix java code tomorrow and look into prices. I've got some 
	questions regarding the price results and the poster day to ask Richard on Monday.
	
7/12/14:
	Started looking at the odds result and I'm unsure of what exactly they mean. I've fixed the java code so that
	it does all that the python code does and gets the same results. Everything is currently hard coded in which
	will need to change but for now I can easily access the market data I want. I'm just getting the java code up
	to speed for being able to collect data by the end of the week and be ready for the project poster day.

8/12/14:
	Started and completed the required submissions for poster day. I had some issues actually calculating the probability of events
	occured but from conversations with Richard I've fixed my misunderstanding and am totally aware of what the program will be doing
	at run time, in terms of extracting probability.

9/12/14:
	Re-worded the documents a little and submitted them.

16/1/15:
	Just finished all other coursework submissions for the year so I'm working on the project again. Last time (something like 28th December
	that I forgot to log) I started on a textual front-end just so I can get some flexible interaction. I'm going to get the front end working
	so commands can be performed with user input. I'll do some tests and set it up so I can finally start collecting game results. I'm planning
	to collect by the 17th since if I want American football to work I need to do it by then. Not many games left before the NFL season ends.
	Fixed some classes used for GSON, removed a lot of parameters that the original betfair examples had that I dont need. I dont need half these
	filters. Currently deciding how I want game recording to work. Probably will have multiple timertask threads or something like that since I can do up to 10 or so requests a second.

18/1/15:
	Decided that I'm going to keep the code from the BetFair repository mostly as if, I'll just clean a few things up. I'm then going to create a class which exclusively has access to it. With the new class I'll simplify method calls and return results from the API in a nicer way, making it a lot easier when it comes to a GUI to display what I want. Going to create a "debug mode" for the app which will print out all
	request and result strings in case something goes bad, since that's what I was doing before. Currently I'm in the middle of replacing depreceated apache 4.2 code with 4.3. I'm still in the middle of writing the front end for collecting results and implementing debug mode. I'm planning on finishing by 21st. I'll then spend the week collecting results and designing/creating my GUI and creating some test cases. Currently the program crashes super hard on things like bad logins.

22/1/15:
	Not started properly working on it yet. I'm delaying collecting data right now because I've had internet going on and off most of the week so far. I've added a package for JUnit testing and I'll start on the report soon. I need to remove ssl certificate file passwords so I can
	remove my hard coding of unnecessary passwords and then I can start making the code not crash and burn when given bad passwords (since the exception won't be there in the near future). I'll finish on the Text front end today hopefully, get a few basic tests done, rename some classes and evaluate some of my older code and the betfair stuff to see if anything needs refactoring or can be removed. I also forgot to push my git changes for a while so something like 5-10 commits just got pushed on the one day off my laptop. Also need to finish replacing
	depreceated apache stuff although that's not too high on my priorities. I've started refactoring method names, I'm not 100% sure if I should really be doing it though but it's moving it from BetFair names to their logical names to another person looking at this code e.g. from getEvents to getGames.

1/2/15:
	Started working on the project again. I'm currently deciding between javafx or swing. Whilst deciding
	I'm back to working on the textual front-end that I plan on replacing soon. Plan for this week is to get the GUI partially done and have collected lots of game data. Ended up replacing most depreceated apache code. What's left is the SSL stuff I don't fully understand.

2/2/15:
	Fixed my p12 certificate and did some work on tests. Currently thinking about how I'll deal with exceptions which ties into my test strategy.

3/2/15:
	Fixed the tests, had issues with thrown exceptions not being recognised properly in the test. I added functionality to grab the list of all games in the next x days. Next up will be requesting game results and then I'll write a little class that will be used to managed Runnables which will be scheduled to start fetching data when a game starts until it's end. I still need to look into fields to see what signifys a start end, market opens before games? do markets shut at half time? etc.

4/2/15:
	Worked on the general text based ui for data gathering. Issue I've come across is that this needs multithreading. So far I wrote it so that multiple markets can be tracked at once. So I wrote a class that handles the threads and distributes the tasks. It will hand out marketids and check on the threads progress, looking to see if it's done so it can store the data in a file. Issue here is that 1. I might just request lots of the same games market data on the same thread, making it a huge pain (probably) to parse it later so I can understand what happens and so I can format it in such a way that when the program is actually doing its job, its not too bad to get the data I want. 2. The betfair code I've written is single threaded, so If I try to track multiple games at the same time then what happens is request sent -> waits for response -> gets response, while the other thread waits, now this could probably still work but it means that requests are sent at something like 2s apart and this gets to a point, where I can be tracking 5 or 6 games and trying to get data every 10s could start failing (on my bad home internet) since so much time is spent waiting. So either tonight or tomorrow I'll re-write my betfair code so that it takes in a request, then assigns that request to a thread and then waits on a reply. I need to look into thread communication again and hope I don't run into too many concurrency issues, and hopefully this isn't too bad to test that its working.
				TextualGUI class -> gets input -> gets given a task -> puts task into a shared collection
								TheadManager running on another thread -> polls shared collection -> recieves task -> assigns task to thread -> checks threads status until completion
																										Task Thread -> Recieves task -> works on task until finish condition

	I think this should be really simple though, I just want to share a list of tasks between my ui and the thread controller, which then distributes and checks on threads progress, probably via another shared list																					
	(On actual program, could work the same way with the manager running and instead of saving stuff to a file, it adds it to some form of collection it works on)

4/2/15:
	Decided that I'll get a quick program written that can take results for me, so that i have something done before I meet with Richard on Friday and I hope to finish this multi threaded thing by the weekend. So far sketched it out in pseduo code in comments. 

5/2/15:
	Finished my simple game data collector. As far as I can tell it works but I won't fully know until about 120 mins from now when the game it's recording ends. For my simple version I'm only observing a single market so I can't tell when half time ends etc, only when game ends (which is when the match odds market ends) once the game ends the data is saved to a file. Right now I'm polling every 5 seconds so a game will be approx 36000 lines of output in its txt... Around about 1k iterations in it crashed since I was accidently calling back bet sizes instead of lays. Tomorrow I plan to talk to Richard about sampling times, need for multithreading for collecting results, how big a sample size I need to start drawing general conclusions, how to analyze all this data. Plan for the next few days for sure is to reformat everything, add some javadoc and look at my code structure, everything was written in a rush. I want to polish it off a little before I start on the next big part of the project. Also I need to start on the first 3 chapters for next weeks hand in and work on other parts of the report

7/2/15:
	After discussing what to do with Richard and how much/what data to get, I've modified the program. Now I record all the data I did before, for reference, and another file is generated after the game ends. The second file is a csv which contains a timestamp along with the predicted probablilty from (highest back - lowest lay)/2 for one selected team that's not the draw market. I think that there's honestly very little useful information you can get from the draw market. If a team is losing then their predicited probability is low (high actual number meaning poor odds since everyone gives you a large multiplier of your bet back if you win), if they score to make it even the goal line then the probability gets better, more goals they score then the better their probability, more behind they are then the worse. The program picks the first non draw runner in a market it gets and tracks their values. The thinking is that I have a first file for reference incase I made a code mistake and the 2nd file contains values that I'll graph in Excel. And possibly look at matlab or something later to graph. With the graph I'll get a list of game events and start looking for patterns in the graph of odds relating to the events. Tomorrow I'll actually have a full game recorded, today I had a few bugs in the code so I'm getting a fairly big Italian football game recorded but the first 20min are missing. The project plan is still loose since I'm considering trying to extract as much from a single sport rather than multiple "poorly" tracked sports. Decisions will be made after looking at the data and talking to Richard. If I try to get better at predicting football events then I'll have to start looking at a lot more markets. Next step is to look at the look at the data and modify the program again so I track all markets and store in separate csv files. This is because initially when it picks a runner, it knows nothing of the current game state even remotely (like who's currently got the best odds) so it just picks it's first choice. What can happen later on, as exampled in one of my earlier tests today, the team gets a blowout victory (in my case 4-0 fast) so lays for the team stop fairly early in the match so there's less data to be collected, and I don't know where it cuts off, it might just stop at 2 or 3 fast goals or 2 fast and reds...

8/2/15:
	Forgot to change one variable in the code and my save didn't store the parsed data, 2 games collected and nothing was stored. Fixing the program and collecting premier league data tomorrow.

9/2/15:
	No big games on today so I'm just refactoring my code, planning UI design and doing some draft chapters.

11/2/15:
	Didn't do much, collected 1 games data since all the big games started at the same time and I haven't added multi threading yet or multiple market tracking. I almost finished the code to store all of a markets runner data in csv so I can generate a graph later. Tomorrows plan is look into tracking multiple markets (data limit or multi threading) and get more data. Also I need to finish draft chapters off.

15/2/15:
	Did heavy code refactoring and some work on hopefully the near final version of the game recorder. There's heavy modifications to go from generating 2 files for a market to 4 and then also support multiple market tracking. Multiple game tracking is also in my plan for its future version, although I'm not implementing that right now since there could be some annoying issues that comes with multiple games with different start times. Currently I think that it's unavoidable to have the program running idle for a long time since the collector will be called every x seconds but say if game 1 finished and game 2 is 4 hours later then it's going to run for 4 hours checking if a game is started and if not it does nothing. It's probably not as bad of a thing as I imagine but it just feels bad. Plan for the week is finish recorder, get 10-15 football + rugby games with lots of markets tracked and write a mock up GUI. I don't plan on thinking about my model until data analysis which I'll talk to Richard about next week. So I'll implement my GUI mockups with a mock object model.

17/2/15:
	Did more work on game recorder and added some helpful methods. In hindsight I've probably not written it the easiest way, at least the method isn't very simple and because the way the betfai api works, there's a lot of additional work. Fairly achieveable plan I think is finish recorder tomorrow and start getting games. Probably little modifications required if I want to do multiple games with multiple markets rather than just 1 game with many markets.

18/2/15:
	Almost finished the new game recorder, I've had lots of bugs due to tired coding. The program did it's job but it did it a few more times than it should have (It was making multiple duplicate entries). Going to just port my old recording code into the new class and it should be ready for tomorrow. I'll probably heavily refactor what I have for now since it's just one massive class.

19/2/15:
	Finished the game recorder. Doing testing tonight and if any bugs i'll fix them tomorrow. I'll probably rewrite it to be more efficient and less confusing to read later on. It's quite confusing because different levels of BetFair are "unaware" of others. Meaningful names for things like game names, market names, etc get turned into codes as you go deeper into the information you can access. So I've got quite a few maps that I use in order to resolve issues like actually putting meaningful information into files and understanding what it's looking at. Game name turns into game id, market name turns into market id, runner name turns into runner id and it gets hard to manage, especially when I added support for multiple markets, tracking all runners and the BetFair api doesn't give data out in the same order it went in, in some instances so I can't easily just go from 0 to limit knowing what market should be 0.

23/2/15:
	Worked on login controllers and views. I've planned all of the gui layouts. I'm just implementing them now. Originally I was going to do this with JavaFx but for the sake of speed, I'm doing it in swing. Almost all I do is transferable if I decide to change my library for guis later.

25/2/15:
	Fixed all known bugs on the new game recorder. It now works as expected and data for multiple sports is being collected. Whilst it collects sports, I'm writing new code tests, considering how to test certain code that's fairly inaccessible and working on the GUI.

5/3/15:
	Forgot to log for a little bit. I've designed my whole program layout and it just needs a hotswappable class for analysing odds for specific games. The plan is for them to have specific behaviour for supported markets. But I want it to be somewhat capable of "winging it" when it comes to unfamiliar markets. Like say if it detects a large change in somethings probability it might just flip the market name for example Sending Off? Teamname to Teamname has had a player sent off. Today I re-wrote my UI to work in terms of interfaces and superclasses so new classes could be swapped in if necessary, as long as they meet my specified method contracts. I've designed the whole system so next up will be to implement the rest of the views until I get to the view for recording/analysis. I've created an interface for both of them which I need to implement. Both will also be timertasks and observable but due to java not allowing multiple inhertiance I'll have to write my own observer/observable interfaces so that the ui can track the model. I want the Recorder/Analysis classes to sit and happily work and routinely throw events to the view. I've not fully decided if it's going to be strings or an object but it's mostly going to be events like updating the game time on the view, throwing game events up, throwing events up like markets shutting or suspended. I may also just throw up all tracked information in a super refined form and perhaps feed into an element on the view that is performing graphing. It's not set in stone but I think my back end design will do the job with few modifications. Tomorrow I'm going to refine my documentation, create the new views, hopefully implement my interfaces for observer/observable and add more code to the game tracker. I'm going to track the amount of money matched for every market available for a game so I can gain more insight into whats not worth tracking at all, thus allowing me to get a better idea of what events can be tracked. Recently a lot of the markets I've been tracking (I'm doing 20 a game roughly) have had 0 matched bets so 0 information can be extracted, these markets are best avoided. I've also gotten more game logs, mostly tennis since rugby isn't on too often and I've managed to miss a lot of premier league games since I can only track one at a time. I'm doubtful that I'll add code to support multiple games since it is quite a lot of modifications for work that only needs performed in this earlyish data collection stage.

8/3/15:
	Did some UI work. Plan is to finish prototype tomorrow. All of the code has been done before with the revamp with parameter passing. I just have to write some more. Also started work on implementing my own observer and event objects for later. Plan is to have all implemented tomorrow with a simplistic model.

11/3/15:
	26 Days 11 hours until submission. I worked on the guis to a point where I now have to implement the final record and analysis views. With my design all relevant information is passed over so it can run as intended. I've designed mockups for the guis. Next step is going to be to implement my uis then the back end which involves modifying my existing classes and implementing observer/observable classes. The plan is to spend almost all of tomorrow on that and do some of the report so I'm at a good spot. A weeks time I plan on finishing everything so I have plenty of time to work on the report and refine any code. It looks like I'm only going to be able to get football working well. I'll try some basic implementating as a catch all for other sports which will just be if theres a big change in odds then I'll reflect the market name and who got the change (biggest change towards 1 not biggest in actuality).

17/3/15:
	Forgot to update log recently due to being ill. Today I removed old remnant classes I had sitting around. I also implemented a marketselect view class that then goes onto the game analysis class. I've decided I'm probably only allowing analysis via the gui and recording can still be done by text based means. There's really no need to implement something with a bad looking ui that I've already done, I'll just add some useful accessory methods to say record many markets in one line like record a,b,c,d rather than record a. record b. etc. I've also been working on the general analysis that I've put off for a little while. I've implemented my own version of of observer pattern that will be used, I've decided to push data up rather than pull for now, this was because I was planning on having different types of events (market shut, general data push, initial data push that has additional info) but I've had an idea to just compact all of that into a little update object but I'll think a little more about it before implementation. Next up is to simplify my Recorder class. At first it got to about 800 lines where it did a lot of initilisation, management of metadata and IO. I've already moved the metadata manangement to DataManager class. Next up will be to take most of its IO out. I plan on using it so that on a tick, it grabs data from the api and throws it to my IO class. It will then grab a nice tidy object that only has data I want (probability, timestamp, and a little more like hometeam, awayteam, starttime since I want to compound all update objects into one) and updates all observers pushing that out. I may rewrite my observer to work in terms of betfairupdate interface or something later on but I've stopped caring about decent design for now. I plan on finishing most of the program by Thursday and then I'll spend the rest of the time refactoring and working on the report. I'm also planning on spending a lot of time doing more data analysis since I've not really worked out the weights I'm using to decide events. So far there's obvious indicators of events on my graphs and I'm thinking about working in terms of gradient. My idea so far is to store 6 points at once (current and 5 previous) this is so that I can look back and see that if there's any major change in gradient that it's consistant. So if I see a big change in gradient I'll flag it and capture 3-4 more points to ensure it's not some remnant bet that's been snapped up by a bot. Then if the change is constant(ish) from that point I'll figure out what happened, most likely just reversing the market name at first for that runner. So the plan is that it will work as long as there's active data and peoples bots are taking remnants fast. The general idea is the whole program is that at first the analysis view starts an analysis object. That in turn starts the gamerecorder which ticks collecting data, this data is thrown back up to the gamerecorder which then feeds it into an analysis class. So if 5 markets are being tracked then there's 5 analysis classes running. They are all checking major changes for in runner probabilitiy, if one is detected then that whole market is flagged (working with the assumption that one markets change is mirrored) and an event is thrown out to gameanalysis which then throws up the probabilitiy data (for graphing, time updates (forgot to say that analysis will convert it to game time, hence why start time is thrown up earlier) and game event updates). Each market is observed with all runners because special cases like next goalscorer are markets where player a scoring may not affect the chance of player b scoring, other normal cases like Match Odds then only 1 runner needs observed (not the draw) and that's it but for now I'm writing it like a catch-all. I feel quite overwhelmed with the project because the scope is unlimited and I feel like my sophistication of modelling is too basic. I'll make a good attempt for football and see if my analysis is a catch-all, if not I'll write a few classes for other sports to try get something out of it but most of the time on this project was writing the whole system that can deal with these 'plug in modules' that do all the work.

24/3/15:
	Fixed almost all of the back end code. I refactored heavily for the past 2 days. I've just got testing, gui and prediction model to do. I've been getting stressed about this recently due to the back end breaking for unknown reasons for a while. So far in the past 2 days I've had to fix errors where recording information wasn't correctly stored, fixed money matched data storage and fixed my alerts, as far as I know now, all data goes correctly to the predictor. Now I just have to get more testing done, finish up the gui, add the graph and then it's all just working on predictors. I'm planning on doing testing by just having 1 class I'll feed data into, take data out and pop it into my analysis class for events. This should allow a very quick way of testing my changes to see results. I think I've written it in a way that works. All classes use the datamanger class for metadata (resolving ids to names etc) and I initilise that with 1 object thats been retrieved from the API. So I'm going to store all JSON request and in my head it should come out in the form of 1 - json for init manager then everything else is json thats passed into the io class. So I should be able to read in the file, get 1st line and make the object then just feed things in quickly. Issues may arise because the unlikely possiblility that I read in faster than the events are handled. I'll find out in practice. I've probably not explained this well but I serialize the objects I receive back to json and store them so that later on for testing purposes I can re-serialize them into objects and simulate the system with them. If I'm unable to do that then I'm unsure as to how I'm going to be able to test this system correctly... I'm getting worried that I'm not going to finish on time because others are on evaluation or doing revision already but I've set some deadlines I plan on meeting. I'm having a meeting with Richard tomorrow where I plan on discussing my way forward with this in terms of goals but I plan on finishing all development by Sunday the 29th. Then the next week is for working on my report.

27/3/15:
	I've been working on my first draft for the report. I'm just writing chapters on topics that I think will go into the report and on the weekend I'll organize it and ask Richard to read it. I'm still doing coding which I'm hoping to finish by Sunday/Monday so I can get the evaluation done etc. Right now I'm in the middle of implementing code that allows me to test the whole program, this invovles adding new special constructors to various objects since all data is extracted from the api. My plan is to replace those lines and instead request data from a testfile class. The dependencies for simuluation are the programoptions class and the raw data. I changed the way the program requests data to a less data intensive version (instead of requests for specific markets and then all markets (for storing how much has been bet)) I just request all markets data, issue with this is that none of my recorded data is in that form so I need to collect a few more games data so I can use it for evaluation. I've also changed my graphing values so I can either record new graphs or write a small python program that will change my lines to use the new formula (its now 1/backlayaverage instead of backlayaverage). International friendlies are on today as well as England playing so I'll probably record that game and use its data.

29/3/15:
	Fixed all back end issues, added timestamps etc. Now all work left is on report, prediction model and the gui.

31/3/15:
	Spend all of yesterday working on the prediction model. It's not really working correctly. It detects spikes in probability and relates them to events. I've only been testing it on 1 games data and I'll swap to another later. It's running on turkey vs netherlands where netherlands were huge favourites and were losing until they scored a 92min equalizer for a raw. The program currently detects 87 spikes in total from all markets and approx 60 from match odds. For some reason other markets aren't getting spikes when expected. I'm leavingit for now and sometime this week I'll go back to it and timestamp my produced events. So that I can at least see if they are being created when expected and other unexpected ones are too. If so then thats good. If not then I'm unsure where to proceed. My current idea is that the false events (hoping that the correct ones are being pushed up) are created by small inconsistancies in proabilities. I've seen large unexplainable dips in the odds, which typically only span 1-3 entries. What I'm considering is either trying to detect a spike by using the mean value of all probabilities and the spike value, seeing if it hits the threshold or not, if it does and the next 3 points are closer to the spike than the mean then I'll assume thats an event, since the spike is consistant after that point. The other option is to just average the 3 points before the spike and see if the points after the spike are closer to the spike value that the points before. The latter option will most likely be implemented first for testing. I think I'm getting a little too stressed with the project by trying to ensure it predicts correctly. It's fairly easy to see what's happening with the human eye but a lot harder to write code that will detect it. I'm currently working on my first draft project report so that Richard can help me with any errors or misplaced chapters. I'm a little unsure of the location of some chapters right now since the work done in them can span many different ones. For example I've got a chapter in related work about betfair that goes over the api, methods and then sport viability and my choice of sport to support. Some of this work might need split up into other chapters but I don't really know. As said before all development is on hold right now, whats left to do is fix the predictor, clean up code, maybe modify my interfaces a little so that I can decouple, fully connect the gui, add a test gui view (only runs off actual code, no ui to deal with it) and probably add a form of inference class that takes in all events that were generated in a minute of predicting and cleaning then up, filtering out what we dont need to know, adding up what we know (spike in match odds + sending off market shut and its before 90min? then red, etc). Work is being done on the report right now. I've got to sort my references and appendices at some point but I'm leaving them for now. I'm having trouble padding out the first few sections but once I hit related work I've got tons of write. Plan is to finish/get close to a first draft tonight (most of testing/eval is being left out since it's not been written yet and the program doesn't fully work yet). In hindsight, 7 days is a lot of time to fix these few issues, especially if I can keep a good work ethic. Due to most of my old game data becoming obselete because I didn't realise I needed to serialize programoptions and timestamp everything, I'm recording 2 more football games tonight.

1/4/15:
	I've taken a short break from the project report. I've worked on the GUI and I'm trying to fix the prediction model. The gui looks pretty ugly but it gets the job done, since I'm quite short on time. I'll probably mention gui improvements under improvements. I've found a game which doesn't match up to what is expected in terms of probability spikes. The correct number of spikes exist but they're significantly later in the graph than they should be. I have no idea why it's like that but I'll mention it in the report.

2/4/15:
	Fixed some GUI layout issues that have annoyed me for a long time now. I've spent most of the day working on the report. I went back and wrote a new abstract and introduction that I'm happy with. I've fixed my references so they're all harvard references now. I'm onto system design. I feel that from this chapter onwards I'll be able to finish them very quickly. I've been struggling with the early ones but I think I'm ok now. I've only got 1 chapter on related work, I want to put at least 1 more in but I'm unsure as exactly what to write. I'll look at the example reports to see if any of it helps, otherwise I'll do it after everything else or when Richard reads my draft.